---
layout: post
title: LevelDB Analysis of Deleted Record Restoration Techniques
date: 2024-09-15 00:00:00
description: This is about the LevelDB forensics analysis by the prosecution.
tags: LevelDB forensics
categories: Prosecution
giscus_comments: true
related_posts: false
toc:
  sidebar: left
---

대검찰청 과제를 하며 공부한 내용들

<br>

## LevelDB Architecture

<br>

LevelDB는 Google이 설계한 Key-Value 저장소로 빠르고 효율적인 데이터 읽기 및 쓰기 작업을 위해 설계된 오픈소스 데이터베이스이다.   
LevelDB의 간단한 구조를 살펴보겠다.    

<div class="leveldb Architecture">
    {% include figure.liquid loading="eager" path="assets/img/leveldb_arch.png" %}
</div>

<br>

LevelDB는 LSM(Log-Structured Merge) Tree 구조를 기반으로한 Key-Value Store로 높은 쓰기 성능과 디스크 공간 효율성을 제공하며 위 그림처럼 MEM(MemTable), IMM(Immutable MemTable), SST(Sorted String Table), LOG 등으로 구성되어있다.   
`MemTable`: LevelDB는 데이터를 우선 메모리에 저장한다. Key-Value 데이터 쌍을 SkipList 형태로 저장하며 Sort된 상태를 유지한다. 그리고 데이터가 가득 차면 IMM으로 전환되며 새 MEM을 생성한다.   
`Immutable MemTable`: 읽기 전용으로 변경된 MemTable이며 디스크로 Flush되기 전에 저장된 형태이다.   
`Flush`: IMM에 저장된 Key-Value 데이터 쌍을 디스크로 내보내는 과정으로 IMM을 SST 형태로 변환하여 디스크에 저장한다.   
`Sorted String Table`: SST는 여러 레벨로 나누어 관리되며 Level 0부터 데이터가 저장된다. Level 0에서는 IMM의 Key-Value 쌍이 바로 Flush되어 데이터 중복이 발생할 수 있지만 Level 1부터는 Compaction 과정을 거치며 중복된 데이터가 삭제된다.   
`Compaction`: 디스크에 저장된 여러 SST 파일을 병합하고 중복 데이터를 제거해 상위 레벨의 SST로 정리하는 과정이다. Compaction이 트리거되는 기준은 level 내 SST 파일이 일정 수(4개) 이상으로 생겼을 때, 또는 이후 level의 SST 파일의 크기가 임계값을 초과했을 때이다. 이후 SST들 간 겹치는 Key 범위를 선택하고 병합해 중복된 Key를 제거하고 정렬된 상태로 상위 level로 보낸다.   
`LOG`: 모든 쓰기 작업은 MEM에 저장되기 전 먼저 WAL(Write-Ahead Log)에 저장된다. 이는 비정상적인 종료 시 데이터 복구를 위해 사용되며 손상된 MEM을 복구할 수 있다.   

<br>



## SST Architecture

LevelDB의 데이터 복구는 크게 메모리에서의 복구, 디스크에서의 복구로 구분할 수 있다. 
먼저 디스크에서의 복구를 설명하기 위해 디스크에서 Key-Value가 저장되는 형태인 SST 구조를 더 자세하게 분석해보겠다.   

<div class="SST Architecture">
    {% include figure.liquid loading="eager" path="assets/img/SST.png" %}
</div>

`Data Block`: variable한 크기로(기본 4KB), Key와 Value 데이터 쌍을 저장하는 장소   
`Filter Block`: variable한 크기로(기본 4KB), Data Block의 타켓 Key가 있는 지 유무 확인   
`Metaindex Block`: variable한 크기로(기본 4KB), Filter Block의 메타 데이터 저장   
`Index Block`: variable한 크기로(기본 4KB), Data Block의 메타 데이터 저장   
`Footer`: variable한 크기로(기본 4KB), Metaindex/Index Block의 Block Handle 관리   


## Entry 구조

<div class="SST Architecture">
    {% include figure.liquid loading="eager" path="assets/img/entry.png" %}
</div>

<br>

SSTable의 각 Block은 Block Builder 함수를 통해 생성하며 각 Block은 동일한 형식(Entry)으로 데이터를 저장되며 위와 같은 Entry 구조를 갖는다.


## 삭제 시나리오



